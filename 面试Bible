*Java多线程并发
	*当只有一个线程写，其它线程都是读的时候，可以用volatile修饰变量
	*当多个线程写，那么一般情况下并发不严重的话可以用Synchronized，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，
		比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。
		所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。
		ReentranLock 可以通过代码释放锁，可以设置锁超时。
	*高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。
		这个时候可以使用并发包下的数据结构，例如ConcurrentHashMap，LinkBlockingQueue，以及原子性的数据结构如：AtomicInteger。
   
*== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 
	等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

*HashMap的底层实现原理：HashMap通过put()和get()方法存值和取值。
	*存值时，通过hashcode()方法计算键的hashcode值，然后找到对应的bucket位置来存储
		键值对，如果两个键值对的键的hashcode值相同，则调用键对象的equals()方法来判断两个键对象是否相同，若相同，新值替换旧值并返回旧值(例：原先
		（16，21），现put(16,22)则22替换21并返回21)，如果两个键对象不同，则使用链表来解决碰撞问题，键值对将会存储在链表的下一个节点中。
	*取值时，通过键对象的equals方法对比传进来的参数，从而找到正确的键值对，然后返回值对象。
相关面试题：
	*什么是HashMap,你为什么用到它？
	*HashMap的工作原理是什么？HashMap的get()方法的工作原理？
	*当两个对象的hashcode相同会发生什么？
	*如果两个键的hashcode相同，你如何获取值对象？
	*如果HashMap的大小超过了负载因子定义的容量，怎么办？
	*在多线程情况下，重新调整HashMap大小会存在什么问题吗？
	*为什么String,Integer这样的wrapper适合作为键？
	*我们可以使用自定义的对象作为键吗？
	链接：https://blog.csdn.net/suifeng629/article/details/82179996
 
*HashMap与HashSet区别
	HashSet：实现了Set接口，不允许集合中有重复的值，将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样
		才能比较对象的值是否相等，以确保set中没有存储相等的对象。如果没有重写这两个方法，将会使用这个方法的默认实现。
	HashMap：实现了Map接口，Map接口对键值进行映射，键不允许重复，Map接口有两个基本实现，HashMap和TreeMap，TreeMap保存了对象
        的排列次序，而HashMap则不能。HashMap允许键和值为null,HashMap是非synchronized的。
	区别：*HashMap使用键对象来计算hashcode值；HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以需要
			使用equals()方法比较对象是否相等，若相等则返回false，否则插入。
		  *HashMap比较快，因为是使用唯一的键来获取对象，而HashSet通过遍历来获取对象。
       
*HashMap与HashTable区别
	*初始长度：HashMap默认情况下容量是16，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为
		容量（3--4，7--8，9--16）。HashTable默认初始化长度为11.
	*扩容：HashMap：当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值是0.75，默认情况下，数组大小
		16，当hashmap中元素个数超过16*0.75=12的时候，就把数组大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。
		HashTable：扩容大小是2倍旧长度+1
	*线程安全：HashMap是非synchronized，而HashTable是synchronized,HashTable是线程安全的，多个线程可以共享一个HashTable；如果没有
		正确的同步的花，多个线程是不能共享HashMap的。
	*速度：由于HashTable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果不需要同步，只需要单一线程，那么使用
		HashMap性能要好过HashTable.
	*迭代器：HashMap的迭代器（Iterator）是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。
	*其他：
	*HashMap可以允许存在一个为null的key和任意个为null的value,但是HashTable中的key和value都不允许为null。当HashMap遇到null
		的key时，它会调用putForNullKey方法来进行处理，对于value没有进行任何处理，只要是对象即可。而当hashtable遇到null时，他会直接抛出
		NullPointerException异常信息。
	*HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是可以将键映射到相应值得类的抽象符类，而AbstractMap是基于Map
		接口实现的，它以最大限度地减少实现此接口所需的工作。
	*HashTable链接：https://www.cnblogs.com/chenssy/p/3643886.html
 
*enumerator迭代器和Iterator迭代器
	*函数接口不同
		Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
		Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
	*Iterator支持fail-fast机制，而Enumeration不支持。
		Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们
		提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
		而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合
		的内容进行操作时，就可能会产生fail-fast事件。
		fail-fast:它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。
		例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是
		简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。
	链接：https://blog.csdn.net/qq_34417408/article/details/80041466

*Synchronized容器和Concurrent容器有什么区别？
	在Java语言中，多线程安全的容器主要分为两种：Synchronized和Concurrent，虽然它们都是线程安全的，但是它们在性能方面差距比较大。
	*Synchronized容器（同步容器）主要通过synchronized关键字来实现线程安全，在使用的时候会对所有的数据加锁。
	 需要注意的是，由于同步容器将所有对容器状态的访问都串行化了，这样虽然保证了线程的安全性，但是这种方法的代价就是严重降低了并发性，当多个线程竞争容器时，吞吐量会严重降低。
	*Concurrent容器（并发容器），Concurrent容器采用了更加智能的方案，该方案不是对整个数据加锁，而是采取了更加细粒度的锁机制，因此，在大并发量的情况下，拥有更高的效率。
	
*Hashtable和ConcurrentHashMap异同点
	*相同点：Hashtable和ConcurrentHashMap存储的内容为键-值对（key-value），且它们都是线程安全的容器。
	*不同点：
		*Hashtable通过使用synchronized修饰方法的方式来实现多线程同步，因此，Hashtable的同步会锁住整个数组。在高并发的情况下，性能会非常差。
		*ConcurrentHashMap作为高吞吐量的线程安全HashMap实现，它采用了锁分离的技术允许多个修改操作并发进行。
		 ConcurrentHashMap采用了更细粒度的锁来提高在并发情况下的效率。ConcurrentHashMap将Hash表默认分为16个桶（每一个桶可以被看作是一个Hashtable），
		 大部分操作都没有用到锁，而对应的put、remove等操作也只需要锁住当前线程需要用到的桶，而不需要锁住整个数据。采用这种设计方式以后，在大并发的情况下，
		 同时可以有16个线程来访问数据。显然，大大提高了并发性。

*left join 和 right join
	*想要获取sc全部数据，student部分数据，两种sql写法如下：
	select student.`SId`, student.`Sname` from student 
	right join(
		select SId from sc
		where sc.`CId` = "02" 
		and sc.`score` > 80
	)s
	on student.`SId` = s.sid

	select * from
	(SELECT sc.SId FROM sc WHERE sc.`CId` = "02" AND sc.`score` > 80) as t1
	left join(select student.`SId`, student.`Sname` from student)as t2
	on t1.`SId` = t2.sid
	
*为何访问网站1连续访问两次，第一次需要输入用户名密码，第二次不用就可以直接登陆了？
	*浏览器A第一次访问网站1时，浏览器A会携带该网址对应的cookie(cookie包含seesionId)去访问服务器，服务器会查看自己已有的sessionId是否有和浏览器带来的cookie中sessionId相同的，
	 因为是第一次访问，没有相同的，服务器会创建一个新的sessionId，给cookie，这时候用户输入用户名密码进行登陆。当用户继续用浏览器A访问同一个网站，由于之前已经访问过，所以，
	 服务器会查到浏览器携带的Cookie中的sessionId,有和服务器中已有的SessionId一致的，所以服务器程序通过判断，该用户之前已经登陆过了，所以第二次访问的时候就不需要再登陆了。
	 如果此时再用浏览器B访问网站1，由于是新的浏览器，那么其中是没有上一个浏览器的cookie的，所以此时，服务器会重新分配一个新的sessionId给浏览器B，同样需要重新填写用户名密码进行登陆。

*Java设计模式
	0简单工厂模式
		*生产电脑，分为hp电脑和lenovo电脑
		01普通
			*创建两个电脑的共同接口
			public interface Computer{
				public void create();
			}
			*创建两个实现类
			public class HpComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is HpComputer");
				}
			}
			public class LenovoComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is LenovoComputer");
				}
			}
			*创建工厂类
			public class ComputerFactory{
				public Computer produce(String type){
					if("Hp".equals(type)){
						return new HpComputer();
					}else if("Lenovo".equals(type)){
						return new LenovoComputer();
					}else{
						System.out.println("请输入正确的类型！");
						return null;
					}
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					ComputerFactory factory = new ComputerFactory();
					Computer computer = factory.produce("Hp");
					computer.create();
				}
			}
			*输出：this is HpComputer
		02多个方法
			*对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象
			而多个工厂方法模式是提供多个工厂方法，分别创建对象。
			*修改ComputerFactory
			public class ComputerFactory{
				public Computer produceHp(){
					return new HpComputer();
				}
				public Computer produceLenovo(){
					return new LenovoComputer();
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					ComputerFactory factory = new ComputerFactory();
					Computer computer = factory.produceHp();
					computer.create();
				} 
			}
			*输出： this is HpComputer
		03多个静态方法
			*将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
			*修改ComputerFactory
			public class ComputerFactory{
				public static Computer produceHp(){
					return new HpComputer();
				}
				public static Computer produceLenovo(){
					return new LenovoComputer();
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					Computer computer = ComputerFactory.produceHp();
					computer.create();
				} 
			}
			*输出： this is HpComputer
	*总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
	 在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，
	 所以，大多数情况下，我们会选用第三种——静态工厂方法模式。
 
	1工厂方法模式
		*简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，因此，就用到工厂方法模式。
		 一旦需要增加新的功能，直接增加新的接口实现类和新的工厂类就可以了，不需要修改之前的代码。
		*创建两个电脑的共同接口
			public interface Computer{
				public void create();
			}
			*创建两个实现类
			public class HpComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is HpComputer");
				}
			}
			public class LenovoComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is LenovoComputer");
				}
			}
			*创建两个工厂类
			public class HpComputerFactory implements Provider{
				@Override
				public Computer produce(){
					return new HpComputer();
				}
			}
			public class LenovoComputerFactory implements Provider{
				@Override
				public Computer produce(){
					return new LenovoComputer();
				}
			}
			*再提供一个工厂接口
			public interface Provider{
				public Computer produce();
			}
			*测试类
			public class Test{
				public static void main(String[] args){
					Provider provider = new HpComputerFactory();
					Computer computer = provider.produce();
					computer.create();
				}
			}
			*输出： this is HpComputer
			*其实这个模式的好处就是，如果你现在想增加一个功能：创建华硕电脑，则只需做一个实现类，实现Computer接口，
			 同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
	
	2抽象工厂模式
		*我们一直都是生产联想和惠普的电脑，但是电脑也有多个产品线：台式机、笔记本和平板等等，联想和惠普都在生产这些
		 不同产品线上的电脑，使用工厂方法模式已经满足不了需求，因此我们需要使用抽象工厂模式来解决这一问题。
		*抽象产品
			*定义抽象产品类
			public abstract class DesktopComputer {
			  public abstract void start();
			}
			public abstract class NotebookComputer {
			   public abstract void start();
			}
			*两个抽象产品类分别为DesktopComputer和NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，
			 用来启动电脑。
		*具体产品
			*具体产品为联想和惠普旗下的台式机和笔记本，如下所示。
			public class LenovoDesktopComputer extends DesktopComputer {
				@Override
				public void start() {
					System.out.println("联想台式电脑启动");
				}
			}

			public class HpDesktopComputer extends DesktopComputer {
				@Override
				public void start() {
					System.out.println("惠普台式电脑启动");
				}
			}

			public class LenovoNotebookComputer extends NotebookComputer {
				@Override
				public void start() {
					System.out.println("联想笔记本电脑启动");
				}
			}
			public class HpNotebookComputer extends NotebookComputer {
				@Override
				public void start() {
					System.out.println("惠普笔记本电脑启动");
				}
			}
		*抽象工厂
			*接着创建生产电脑的抽象工厂，如下所示，
			public abstract class ComputerFactory {
				public abstract DesktopComputer createDesktopComputer();
				public abstract NotebookComputer createNotebookComputer();
			}
			*定义了两个方法，分别用来生产台式电脑和笔记本电脑
		*具体工厂
			*定义联想和惠普工厂：
			public class LenovoFactory extends ComputerFactory {
				@Override
				public DesktopComputer createDesktopComputer() {
					return new LenovoDesktopComputer();
				}
				@Override
				public NotebookComputer createNotebookComputer() {
					return new LenovoNotebookComputer();
				}
			}

			public class HpFactory extends ComputerFactory {
				@Override
				public DesktopComputer createDesktopComputer() {
					return new HpDesktopComputer();
				}

				@Override
				public NotebookComputer createNotebookComputer() {
					return new HpNotebookComputer();
				}
			}
			*联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。
		*客户端调用
			public class Client {
				public static void main(String[]args) {
					ComputerFactory lenocoFactory=new LenovoFactory();
					lenocoFactory.createDesktopComputer().start();
					lenocoFactory.createNotebookComputer().start();
					ComputerFactory hpFactory=new HpFactory();
					hpFactory.createDesktopComputer().start();
					hpFactory.createNotebookComputer().start();
				}
			}
		*工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"。
		 抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上。
	 
	3.代理模式
		*其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？
		 因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，
		 因为律师在法律方面有专长，可以替我们进行操作。
		
		*接口类：
		package proxy.staticproxy;
		public interface Person {
			void giveMoney();
		}
		
		*一个实现了接口类的实体类：
		package proxy.staticproxy;
		public class Student implements Person {
			@Override
			public void giveMoney() {
				System.out.println(name +" 上交班费50元！");
			}
			private String name;

			public Student(String name){
				this.name = name;
			}
		}
		
		*一个代理类，代理类实现了接口类，并且还“爱管闲事”，调用了上面实体类的方法。
		package proxy.staticproxy;
		/**
		 * 如果使用动态代理这个类会被自动创建， 代理类的工作就是把实体类接过来，然后调用它的方法，也就是说本来实体类可以自己执行的方法现在由代理类来触发执行，这样做的好处是，在调用实体类方法的前后我们可以插入监控方法。比如这里只插入了一句话“这位同学最近学习有进步”
		 */
		public class StudentProxy implements Person {
			@Override
			public void giveMoney() {
				System.out.println("这位同学最近学习有进步！");
				stu.giveMoney();
			}

			Student stu;

			public StudentProxy (Person stu){
				if(stu.getClass() == Student.class){ //person 可以是学生，老师等， 但是这里只为学生交钱
					this.stu = (Student)stu;
				}
			}
		}
		
		*最后有一个统管类, 生成一个实体类，并指挥代理类去调用实体类：
		public class StaticProxyTest {
			public static void main(String[] args) {
				Person zhangsan = new Student("张三");

				Person monitor = new StudentProxy(zhangsan); // 为了帮张三交班费而生产一个班长角色
				monitor.giveMoney();
			}
		}
		
		*代理模式的应用场景：
		如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
		1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
		2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
		   使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

*Java 中操作字符串都有哪些类？它们之间有什么区别？
	*操作字符串的类有：String、StringBuffer、StringBuilder。
	*String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，
	*StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。
	*StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，
	 所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
	 
*如何将字符串反转？
	使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。
	
*String str="i"与 String str=new String("i")一样吗？
	不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

*JVM内存模型
	*java虚拟机在执行程序过程中会把它所管理的内存划分为几个不同的区域：
	方法区、java堆、java栈、本地方法栈、程序计数器
	其中，java栈、本地方法栈、程序计数器是线程隔离的区域，每个线程都有各自的一份，而方法区，
	java栈是线程共享的。
	*程序计数器
		*程序计数器又叫指令计数器，用来确定cpu下一条要执行的指令的地址。如果当前线程正在执行一个java方法，则程序计数器记录正在执行的java字节码地址，
		 如果当前线程正在执行一个本地方法，那么程序计数器为空。
	*java栈
		*每一个线程都有一个私有的java栈，java栈在线程创建的时候被创建，其中保存着帧信息。每个java方法在执行的同时都会创建一个栈帧，用于保存局部变量、方法参数、
		 方法出口等信息，每一个方法从调用到执行完成的过程，都对应着一个栈帧在java栈中入栈到出栈的过程）
		 栈的优势去访问速度比堆要快，仅次于程序计数器。
	*本地方法栈
		*本地方法栈和java栈非常类似，不同之处在于java栈用于java方法的调用，而本地方法栈用于本地方法的调用。
         注意：本地方法栈不是用java实现的，而是使用C实现的。
	*java堆
		*堆在JVM启动的时候会被创建，我们可以把它理解成一个内存池，用来存放所有的java对象，所有的线程共享java堆。
	*方法区（包含常量池）
		*方法区和堆一样是所有线程共享的区域，主要保存的信息是类的元数据，包括类的类型信息、常量、静态变量、域信息、方法信息等数据。
 
*接口和类
	*java之所以引入接口，就是为了弥补不能多继承的缺点，在java中每个类只能有一个超类，但却可以实现多个接口。
	*接口的思想不允许出现变量，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放。所以接口中的属性必然是常量，
	 只能读不能改，这样才能为实现接口的对象提供一个统一的属性。
	*接口可以有静态常量，并且这个常量一定是静态的，为什么？
　　 因为static是所有对象可以访问，而且可以直接通过类名访问。接口没有对象，必须通过类名来访问所以是要静态的。
	
	*区别：
		*实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
		*构造函数：抽象类可以有构造函数；接口不能有。
		*实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
		*访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

*抽象类能使用 final 修饰吗？
	不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，

*null != a 要比a != null 好
	在于避免由于编码失误造成把a赋值为null,只是编码风格上的区别，效率是一样的； 
	这个与equals是类似的。比如 
	String str = ..; 
	if(str.equals("admin")) 
	这样使用的话，一旦str是null将导致空指针异常，所以我们推荐使用 
	if("admin".equals(str)) 
	这样就没有问题了
	
*阻塞和非阻塞 同步和异步
	*同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，
	 两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。
	 至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。
	*阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，
	 等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 
	 使用时间能不能补偿系统的切换成本需要好好评估。
	 
*BIO、NIO、AIO的区别
    BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，
	    它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。
    NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。
    AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，
	    也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

*Java 容器都有哪些？
	Java容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：
    Collection
    List
        ArrayList
        LinkedList
        Vector
        Stack
    Set
        HashSet
        LinkedHashSet
        TreeSet
		
    Map
    HashMap
        LinkedHashMap
    TreeMap
    ConcurrentHashMap
    Hashtable

*Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。
 Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。

*HashMap 和 Hashtable 有什么区别？
    存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。
    线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。
    推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。

* HashMap 的实现原理？
	HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 
	保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。

*Vector
	Vector 可实现自动增长的对象数组。 
	java.util.vector提供了向量类(Vector)以实现类似动态数组的功能。 
	创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。	
	对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况，可以考虑使用向量类。
	
*ArrayList 和 Vector 的区别是什么？
    线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
    性能：ArrayList 在性能方面要优于 Vector。
    扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。
	
*Array 和 ArrayList 有何区别？
    Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。
    Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。
    Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。
	
*在Queue 中 poll()和 remove()有什么区别？
    相同点：都是返回第一个元素，并在队列中删除返回的对象。
    不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常
	
*Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。也可以通过Iterator去删除元素。 
 Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
 
*Iterator 和 ListIterator 有什么区别？
    Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。
    Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。
    ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。

*怎么确保一个集合不能被修改？
	可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。

*并发与并行
	并行：多个处理器或多核处理器同时处理多个任务。
	并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。
	
*线程和进程的区别？
	一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。

*守护线程是什么？
	守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。

*线程的状态：
    NEW 尚未启动
    RUNNABLE 正在执行中
    BLOCKED 阻塞的（被同步锁或者IO锁阻塞）
    WAITING 永久等待状态
    TIMED_WAITING 等待指定的时间重新被唤醒的状态
    TERMINATED 执行完成

*sleep() 和 wait() 有什么区别？
    类的不同：sleep() 来自 Thread，wait() 来自 Object。
    释放锁：sleep() 不释放锁；wait() 释放锁。
    用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。
	
*在 Java 程序中怎么保证多线程的运行安全？
    方法一：使用安全类，比如 Java. util. concurrent 下的类。
    方法二：使用自动锁 synchronized。
    方法三：使用手动锁 Lock。

*Synchronized锁的3种使用形式（使用场景）：
    Synchronized修饰普通同步方法：锁对象当前实例对象；
    Synchronized修饰静态同步方法：锁对象是当前的类Class对象；
    Synchronized修饰同步代码块：锁对象是Synchronized后面括号里配置的对象，这个对象可以是某个对象（xlock），也可以是某个类（Xlock.class）；
注意：
    使用synchronized修饰非静态方法或者使用synchronized修饰代码块时制定的为实例对象时，同一个类的不同对象拥有自己的锁，因此不会相互阻塞。
    使用synchronized修饰类和对象时，由于类对象和实例对象分别拥有自己的监视器锁，因此不会相互阻塞。
    使用使用synchronized修饰实例对象时，如果一个线程正在访问实例对象的一个synchronized方法时，其它线程不仅不能访问该synchronized方法，该对象的其它synchronized方法也不能访问，因为一个对象只有一个监视器锁对象，但是其它线程可以访问该对象的非synchronized方法。
    线程A访问实例对象的非static synchronized方法时，线程B也可以同时访问实例对象的static synchronized方法，因为前者获取的是实例对象的监视器锁，而后者获取的是类对象的监视器锁，两者不存在互斥关系。

*多线程中 synchronized 锁升级的原理是什么？
	在锁对象的对象头里有一个threadid字段，在线程第一次访问的时候threadid为空，jvm让线程A持有该对象的偏向锁，并设置threadid为线程A的id，再次有线程访问该对象的时候，会先判断threadid和访问线程的id是否一致，如果一致，即还是线程A访问，那么无需使用CAS来加锁解锁，
	即可直接使用该对象，如果不是线程A访问（即线程B访问），那么需要查看java对象头中记录的线程A是否存活，如果没有存活，那么锁对象被设置为无锁状态，其他线程（线程B）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程A）的栈帧信息，如果线程A还是需要继续持有
	持有这个锁对象，那么暂停当前线程A，撤销其偏向锁，升级为轻量级锁。此时线程B通过自旋等待线程A释放锁，然后再获取锁（这里同样线程B获取锁也不需要加锁解锁），
	如果线程B自旋了一定的次数之后，线程A还是没有释放锁，或者线程A还在执行，线程B还在自旋等待，这时又来了一个线程C来竞争这个锁对象，那么这个时候线程A拥有的轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的其他线程都阻塞，防止CPU空转。
注意：	
	*锁的4中状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）
	*为什么要引入偏向锁？
		因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
	*为什么要引入轻量级锁？
		轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放
	*为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。
相关链接：https://blog.csdn.net/tongdanping/article/details/79647337

*锁粗化
	*如果存在一系列的连续加锁解锁操作，可能会导致不必要的资源消耗，因为加锁解锁需要消耗资源，因此，锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

*锁消除
	*jvm在JIT（即时编译：当某段代码即将第一次被执行时进行编译）编译时，通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。

*怎么防止死锁？
    尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
    尽量使用 Java. util. concurrent 并发类代替自己手写锁。
    尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
    尽量减少同步的代码块。
	
*ThreadLocal 是什么？有哪些使用场景？
	ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
	ThreadLocal 的经典使用场景是数据库连接和 session 管理等。

*Synchronized底层实现原理
	synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。
	当synchronized修饰代码块时，需要在同步的代码块开始的位置插入monitorentry指令，在同步结束的位置或者异常出现的位置插入monitorexit指令；JVM要保证monitorentry和monitorexit都是成对出现的，任何对象都有一个monitor与之对应，当这个对象的monitor被持有以后，它将处于锁定状态。
    当synchronized修饰方法时，通过读取常量池中的ACC_SYNCHRONIZED标志，若ACC_SYNCHRONIZED被设置，那么线程在执行方法前会先去获取对象的monitor对象，如果获取成功则执行方法代码，执行完毕后释放monitor对象，如果monitor对象已经被其它线程获取，那么当前线程被阻塞。

*synchronized 和 volatile 的区别是什么？
    volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
    volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
    volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

*synchronized 和 Lock 有什么区别？
    synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
    synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
    通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

*synchronized 和 ReentrantLock(锁一个对象，可以锁上多次) 区别是什么？
	synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。
	主要区别如下：
    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；
    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；
    ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等

*CAS
	Compare and Swap，即比较再交换。
	每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。
	例：AtomicInteger.incrementAndGet的实现用了乐观锁技术，调用了类sun.misc.Unsafe库里面的 CAS算法，用CPU指令来实现无锁自增。所以，AtomicInteger.incrementAndGet的自增比用synchronized的锁效率倍增。
	public  final int incrementAndGet(){
		for(;;){
			int current = get();
			int next = current + 1;
			if(compareAndSet(current, next)){
				return next;
			}
		}
	}

*Atomic实现原理
	atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。
	CAS：public final int getAndAddInt(Object o, long offset, int delta) {
		 int v;
		 do {
		 v = getIntVolatile(o, offset);//------------0---------------
		 } while (!compareAndSwapInt(o, offset, v, v + delta));//-------------1-------------
			return v;
		 }

	volatile: private volatile int value;value是一个volatile变量，在内存中可见，任何线程都不允许对其进行拷贝，因此JVM可以保证任何时刻任何线程总能拿到该变量的最新值。
	native方法：objectFieldOffset() 这个方法是用来拿到我们上文提到的这个“原来的值”的内存地址。是一个本地方法，返回值是valueOffset。
注意：*语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。所以说，CAS并
       不是无阻塞，只是阻塞并非在语言、线程方面，而是在硬件层面，所以无疑这样的操作会更快更高效！
	  *虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了。
	  *虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了。
	  *虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了。

*反射
	正射：直接对这个类进行实例化，之后使用这个类对象进行操作。
		Phone phone = new Phone(); //直接初始化，「正射」
		phone.setPrice(4);
	反射：一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。
		Class clz = Class.forName("com.xxp.reflect.Phone");
		Method method = clz.getMethod("setPrice", int.class);
		Constructor constructor = clz.getConstructor();
		Object object = constructor.newInstance();
		method.invoke(object, 4);
	所以：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
	
*获取反射中的Class对象
	在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。
	在 Java API 中，获取 Class 类对象有三种方法：
    *使用 Class.forName 静态方法。当知道某类的全路径名时，可以使用此方法获取 Class 类对象。用的最多，但可能抛出 ClassNotFoundException 异常。
     Class c1 = Class.forName(“java.lang.String”);
    *直接通过 类名.class 的方式得到，该方法最为安全可靠，程序性能更高。这说明任何一个类都有一个隐含的静态成员变量 class。这种方法只适合在编译前就知道操作的 Class。
     Class c2 = String.class;
    *通过对象调用 getClass() 方法来获取，通常应用在：比如你传过来一个 Object类型的对象，而我不知道你具体是什么类，用这种方法。

*通过反射创建类对象
	通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。
    通过 Class 对象的 newInstance() 方法。
		Class clz = Phone.class;
		Phone phone = (Phone)clz.newInstance();
    通过 Constructor 对象的 newInstance() 方法
		Class clz = Phone.class;
		Constructor constructor = clz.getConstructor();
		Phone phone= (Phone)constructor.newInstance();
	通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。
	
*通过反射获取类属性、方法、构造器
	我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。
		Class clz = Phone.class;
		Field[] fields = clz.getFields();
		for (Field field : fields) {
			System.out.println(field.getName());
		}
	如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：
		Class clz = Phone.class;
		Field[] fields = clz.getDeclaredFields();
		for (Field field : fields) {
			System.out.println(field.getName());
		}
	与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。

*反射应用场景
	反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，
	并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，
	降低代码的耦合度；还有动态代理的实现；JDBC原生代码注册驱动；hibernate的实体类；hibernate数据查询：Spring的AOP等等。

*new和反射创建对象的区别
	*首先new出来的对象我们无法访问其中的私有属性，但是通过反射出来的对象我们可以通过setAccessible()方法
	 来访问其中的私有属性。
	*在使用new创建一个对象实例的时候必须知道类名，但是通过反射创建对象有时候不需要知道类名也可以	
     （ 首先要使用反射创建对象必须要得到类的Class对象，至于怎么得到这个Class对象，有很多方法例如对于类A及其
		实例str_a来说可以使用A.class()，str_a.getClass()或者Class.forName("A")。这几种方法无一例外都需要使用到类名来
		获取类Class对象，但是有一种方式是不需要类名的，那就是jdk的动态代理。动态代理是一种在运行期动态生成字节
		码并转换成代理类Class对象的一种方法
	  ）
	  
* 什么是 Java 序列化？什么情况下需要序列化？
	*Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。
	*以下情况需要使用 Java 序列化：
		想把的内存中的对象状态保存到一个文件中或者数据库中时候；
		想用套接字在网络上传送对象的时候；
		想通过RMI（远程方法调用）传输对象的时候。

*java程序编译和运行
	编译：XXX.java --> XXX.class。编译时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类。
		  编译后的字节码文件主要分成两部分：常量池和方法字节码。
		  
	运行：分两个过程：类的加载和类的执行
		  JVM在程序第一次主动使用类的时候，才加载该类。所以，jvm并不是在一开始就把一个程序所有的类都加载到内存（
		  例如：命令行敲java AppMain 系统先加载MainApp类，然后执行main函数，这时发现main函数第一条命令是Animal animal = new Animal()，这时jvm才去加载Animal类）。
参考链接：https://blog.csdn.net/cynhafa/article/details/82425456

*动态代理
	*与静态代理区别：代理类在程序运行时根据我们在java代码中的“指示”创建代理的方式被称为动态代理。而静态代理在程序编译的时候就已经将接口，被代理类，代理类确定下来了。
		             相比与静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用说修改每个代理类中的方法。比如说：在静态代理中，班长帮学生交学费，
					 静态代理中有giveMoney()方法，里面调用的是stu.giveMoney(),我们可以在交学费之前做一些处理，比如打印该学生所需交的费用，如果这时又有另外一个交伙食费的方法，
					 我们同样需要在交伙食费之前打印费用信息，这时，需要再次在stu.giveFoodMoney()方法之前添加打印方法，这样一来，打印费用方法就要写很多次，而动态代理，只需写一次即可。
	*动态代理实现：jdk的动态代理主要是通过Proxy类和InvocationHandler接口生成JDK动态代理类和动态代理对象。其中：InvocationHandler用于表示在执行某个方法之前，之后你想加入什么（监控）代码。
				   Proxy用于自动生成代理类，InvocationHandler将会作为Proxy的一个参数来生成代理类。
				   两者通过Proxy.newInstance()方法进行关联，invocationHandler会作为参数传入Proxy， 由Proxy在编译的时候加工自动生成代理类，这个生成的代理类里就会有invocationHandler里指定的要执行的代码

					public class ProxyTest {
					public static void main(String[] args) {
						
							//创建一个实例对象，这个对象是被代理的对象
							Person zhangsan = new Student("张三");
							
							//创建一个与代理对象相关联的InvocationHandler
							//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
							Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class<?>[]{Person.class}, new StuInvocationHandler<Person>(zhangsan))；

						   //代理执行上交班费的方法
							stuProxy.giveMoney();
						}
					}
					

					import java.lang.reflect.InvocationHandler;
					import java.lang.reflect.Method;

					public class StuInvocationHandler<T> implements InvocationHandler {
						T target;

						public StuInvocationHandler(T target){
							this.target = target;
						}
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							System.out.println("代理执行"+method.getName()+"方法");

							MonitorUtil.start(); //这是一个本地静态工具类，用于记下方法开始时间
							Object result = method.invoke(target, args);
							MonitorUtil.finish(method.getName());//这是一个本地静态工具类，用于记下方法执行完成的时间
							return result;
						}
					}
参考链接：https://www.jianshu.com/p/4e14dd223897      
          https://www.cnblogs.com/gonjan-blog/p/6685611.html
			 
*Sring的两种动态代理：Jdk和Cglib
	*JDK:java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
	*Cglib:而cglib动态代理是利用asm开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
	区别：（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类
		  （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
               因为是继承，所以该类或方法最好不要声明成final 
	注意： 1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
		   2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
           3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
具体区别及实现见链接：https://www.cnblogs.com/leifei/p/8263448.html