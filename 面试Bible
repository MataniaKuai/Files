*Java多线程并发
	*当只有一个线程写，其它线程都是读的时候，可以用volatile修饰变量
	*当多个线程写，那么一般情况下并发不严重的话可以用Synchronized，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，
		比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。
		所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。
		ReentranLock 可以通过代码释放锁，可以设置锁超时。
	*高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。
		这个时候可以使用并发包下的数据结构，例如ConcurrentHashMap，LinkBlockingQueue，以及原子性的数据结构如：AtomicInteger。
		
*Synchronized容器和Concurrent容器有什么区别？
	在Java语言中，多线程安全的容器主要分为两种：Synchronized和Concurrent，虽然它们都是线程安全的，但是它们在性能方面差距比较大。
	*Synchronized容器（同步容器）主要通过synchronized关键字来实现线程安全，在使用的时候会对所有的数据加锁。
	 需要注意的是，由于同步容器将所有对容器状态的访问都串行化了，这样虽然保证了线程的安全性，但是这种方法的代价就是严重降低了并发性，当多个线程竞争容器时，吞吐量会严重降低。
	*Concurrent容器（并发容器），Concurrent容器采用了更加智能的方案，该方案不是对整个数据加锁，而是采取了更加细粒度的锁机制，因此，在大并发量的情况下，拥有更高的效率。
	
*并发与并行
	并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。
	并行：多个处理器或多核处理器同时处理多个任务。
	
*线程和进程的区别？
	一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。

*守护线程是什么？
	守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。

*线程的状态：
    NEW 尚未启动
    RUNNABLE 正在执行中
    BLOCKED 阻塞的（被同步锁或者IO锁阻塞）
    WAITING 永久等待状态
    TIMED_WAITING 等待指定的时间重新被唤醒的状态
    TERMINATED 执行完成

*sleep() 和 wait() 有什么区别？
    类的不同：sleep() 来自 Thread，wait() 来自 Object。
    释放锁：sleep() 不释放锁；wait() 释放锁。
    用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。
	sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。
    sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。
链接：https://blog.csdn.net/qq_34490018/article/details/81609147
	
*在 Java 程序中怎么保证多线程的运行安全？
    方法一：使用安全类，比如 Java. util. concurrent 下的类。
    方法二：使用自动锁 synchronized。
    方法三：使用手动锁 Lock。

*Synchronized锁的3种使用形式（使用场景）：
    Synchronized修饰普通同步方法：锁对象当前实例对象；
    Synchronized修饰静态同步方法：锁对象是当前的类Class对象；
    Synchronized修饰同步代码块：锁对象是Synchronized后面括号里配置的对象，这个对象可以是某个对象（xlock），也可以是某个类（Xlock.class）；
注意：
    使用synchronized修饰非静态方法或者使用synchronized修饰代码块时指定的为实例对象时，同一个类的不同对象拥有自己的锁，因此不会相互阻塞。
    使用synchronized修饰类和对象时，由于类对象和实例对象分别拥有自己的监视器锁，因此不会相互阻塞。
    使用synchronized修饰实例对象时，如果一个线程正在访问实例对象的一个synchronized方法时，其它线程不仅不能访问该synchronized方法，该对象的其它synchronized方法也不能访问，因为一个对象只有一个监视器锁对象，但是其它线程可以访问该对象的非synchronized方法。
    线程A访问实例对象的非static synchronized方法时，线程B也可以同时访问实例对象的static synchronized方法，因为前者获取的是实例对象的监视器锁，而后者获取的是类对象的监视器锁，两者不存在互斥关系。

*多线程中 synchronized 锁升级的原理是什么？
	在锁对象的对象头里有一个threadid字段，在线程第一次访问的时候threadid为空，jvm让线程A持有该对象的偏向锁，并设置threadid为线程A的id，再次有线程访问该对象的时候，会先判断threadid和访问线程的id是否一致，如果一致，即还是线程A访问，那么无需使用CAS来加锁解锁，
	即可直接使用该对象，如果不是线程A访问（即线程B访问），那么需要查看java对象头中记录的线程A是否存活，如果没有存活，那么锁对象被设置为无锁状态，其他线程（线程B）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程A）的栈帧信息，如果线程A还是需要继续持有
	持有这个锁对象，那么暂停当前线程A，撤销其偏向锁，升级为轻量级锁。此时线程B通过自旋等待线程A释放锁，然后再获取锁（这里同样线程B获取锁也不需要加锁解锁），
	如果线程B自旋了一定的次数之后，线程A还是没有释放锁，或者线程A还在执行，线程B还在自旋等待，这时又来了一个线程C来竞争这个锁对象，那么这个时候线程A拥有的轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的其他线程都阻塞，防止CPU空转。
注意：	
	*锁的4中状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）
	*为什么要引入偏向锁？
		因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
	*为什么要引入轻量级锁？
		轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放
	*为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。
相关链接：https://blog.csdn.net/tongdanping/article/details/79647337

*锁粗化
	*如果存在一系列的连 续加锁解锁操作，可能会导致不必要的资源消耗，因为加锁解锁需要消耗资源，因此，锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

*锁消除
	*jvm在JIT（即时编译：当某段代码即将第一次被执行时进行编译）编译时，通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。

*怎么防止死锁？
    尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
    尽量使用 Java. util. concurrent 并发类代替自己手写锁。
    尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
    尽量减少同步的代码块。
	
*ThreadLocal 是什么？有哪些使用场景？
	ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
	ThreadLocal 的经典使用场景是数据库连接和 session 管理等。

*Synchronized底层实现原理
	synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。
	当synchronized修饰代码块时，需要在同步的代码块开始的位置插入monitorentry指令，在同步结束的位置或者异常出现的位置插入monitorexit指令；JVM要保证monitorentry和monitorexit都是成对出现的，任何对象都有一个monitor与之对应，当这个对象的monitor被持有以后，它将处于锁定状态。
    当synchronized修饰方法时，通过读取常量池中的ACC_SYNCHRONIZED标志，若ACC_SYNCHRONIZED被设置，那么线程在执行方法前会先去获取对象的monitor对象，如果获取成功则执行方法代码，执行完毕后释放monitor对象，如果monitor对象已经被其它线程获取，那么当前线程被阻塞。

*synchronized 和 volatile 的区别是什么？
    volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
    volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
    volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

*synchronized 和 Lock 有什么区别？
    synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
    synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
    通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

*synchronized 和 ReentrantLock(锁一个对象，可以锁上多次) 区别是什么？
	synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。
	主要区别如下：
    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；
    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；
    ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等

*CAS
	Compare and Swap，即比较再交换。
	每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。
	例：AtomicInteger.incrementAndGet的实现用了乐观锁技术，调用了类sun.misc.Unsafe库里面的 CAS算法，用CPU指令来实现无锁自增。所以，AtomicInteger.incrementAndGet的自增比用synchronized的锁效率倍增。
	public  final int incrementAndGet(){
		for(;;){
			int current = get();
			int next = current + 1;
			if(compareAndSet(current, next)){
				return next;
			}
		}
	}

*Atomic实现原理
	atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。
	CAS：public final int getAndAddInt(Object o, long offset, int delta) {
		 int v;
		 do {
		 v = getIntVolatile(o, offset);//------------0---------------
		 } while (!compareAndSwapInt(o, offset, v, v + delta));//-------------1-------------
			return v;
		 }

	volatile: private volatile int value;value是一个volatile变量，在内存中可见，任何线程都不允许对其进行拷贝，因此JVM可以保证任何时刻任何线程总能拿到该变量的最新值。
	native方法：objectFieldOffset() 这个方法是用来拿到我们上文提到的这个“原来的值”的内存地址。是一个本地方法，返回值是valueOffset。
注意：*语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。所以说，CAS并
       不是无阻塞，只是阻塞并非在语言、线程方面，而是在硬件层面，所以无疑这样的操作会更快更高效！
	  *虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了。
   
*== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 
	等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

*HashMap的底层实现原理：HashMap通过put()和get()方法存值和取值。
	*存值时，通过hashcode()方法计算键的hashcode值，然后找到对应的bucket位置来存储
		键值对，如果两个键值对的键的hashcode值相同，则调用键对象的equals()方法来判断两个键对象是否相同，若相同，新值替换旧值并返回旧值(例：原先
		（16，21），现put(16,22)则22替换21并返回21)，如果两个键对象不同，则使用链表来解决碰撞问题，键值对将会存储在链表的下一个节点中。
	*取值时，通过键对象的equals方法对比传进来的参数，从而找到正确的键值对，然后返回值对象。
相关面试题：
	*什么是HashMap,你为什么用到它？
	*HashMap的工作原理是什么？HashMap的get()方法的工作原理？
	*当两个对象的hashcode相同会发生什么？
	*如果两个键的hashcode相同，你如何获取值对象？
	*如果HashMap的大小超过了负载因子定义的容量，怎么办？
	*在多线程情况下，重新调整HashMap大小会存在什么问题吗？
	*为什么String,Integer这样的wrapper适合作为键？
	*我们可以使用自定义的对象作为键吗？
	链接：https://blog.csdn.net/suifeng629/article/details/82179996
 
*HashMap与HashSet区别
	HashSet：实现了Set接口，不允许集合中有重复的值，将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样
		才能比较对象的值是否相等，以确保set中没有存储相等的对象。如果没有重写这两个方法，将会使用这个方法的默认实现。
	HashMap：实现了Map接口，Map接口对键值进行映射，键不允许重复，Map接口有两个基本实现，HashMap和TreeMap，TreeMap保存了对象
        的排列次序，而HashMap则不能。HashMap允许键和值为null,HashMap是非synchronized的。
	区别：*HashMap使用键对象来计算hashcode值；HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以需要
			使用equals()方法比较对象是否相等，若相等则返回false，否则插入。
		  *HashMap比较快，因为是使用唯一的键来获取对象，而HashSet通过遍历来获取对象。
       
*HashMap与HashTable区别
	*初始长度：HashMap默认情况下容量是16，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为
		容量（3--4，7--8，9--16）。HashTable默认初始化长度为11.
	*扩容：HashMap：当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值是0.75，默认情况下，数组大小
		16，当hashmap中元素个数超过16*0.75=12的时候，就把数组大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。
		HashTable：扩容大小是2倍旧长度+1
	*线程安全：HashMap是非synchronized，而HashTable是synchronized,HashTable是线程安全的，多个线程可以共享一个HashTable；如果没有
		正确的同步的花，多个线程是不能共享HashMap的。
	*速度：由于HashTable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果不需要同步，只需要单一线程，那么使用
		HashMap性能要好过HashTable.
	*迭代器：HashMap的迭代器（Iterator）是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。
	*其他：
	*HashMap可以允许存在一个为null的key和任意个为null的value,但是HashTable中的key和value都不允许为null。当HashMap遇到null
		的key时，它会调用putForNullKey方法来进行处理，对于value没有进行任何处理，只要是对象即可。而当hashtable遇到null时，他会直接抛出
		NullPointerException异常信息。
	*HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是可以将键映射到相应值得类的抽象符类，而AbstractMap是基于Map
		接口实现的，它以最大限度地减少实现此接口所需的工作。
	*HashTable链接：https://www.cnblogs.com/chenssy/p/3643886.html
 
*enumerator迭代器和Iterator迭代器
	*函数接口不同
		Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
		Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
	*Iterator支持fail-fast机制，而Enumeration不支持。
		Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们
		提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
		而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合
		的内容进行操作时，就可能会产生fail-fast事件。
		fail-fast:它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。
		例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是
		简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。
	链接：https://blog.csdn.net/qq_34417408/article/details/80041466
	
*Hashtable和ConcurrentHashMap异同点
	*相同点：Hashtable和ConcurrentHashMap存储的内容为键-值对（key-value），且它们都是线程安全的容器。
	*不同点：
		*Hashtable通过使用synchronized修饰方法的方式来实现多线程同步，因此，Hashtable的同步会锁住整个数组。在高并发的情况下，性能会非常差。
		*ConcurrentHashMap作为高吞吐量的线程安全HashMap实现，它采用了锁分离的技术允许多个修改操作并发进行。
		 ConcurrentHashMap采用了更细粒度的锁来提高在并发情况下的效率。ConcurrentHashMap将Hash表默认分为16个桶（每一个桶可以被看作是一个Hashtable），
		 大部分操作都没有用到锁，而对应的put、remove等操作也只需要锁住当前线程需要用到的桶，而不需要锁住整个数据。采用这种设计方式以后，在大并发的情况下，
		 同时可以有16个线程来访问数据。显然，大大提高了并发性。

*left join 和 right join
	*想要获取sc全部数据，student部分数据，两种sql写法如下：
	select student.`SId`, student.`Sname` from student 
	right join(
		select SId from sc
		where sc.`CId` = "02" 
		and sc.`score` > 80
	)s
	on student.`SId` = s.sid

	select * from
	(SELECT sc.SId FROM sc WHERE sc.`CId` = "02" AND sc.`score` > 80) as t1
	left join(select student.`SId`, student.`Sname` from student)as t2
	on t1.`SId` = t2.sid
	
*为何访问网站1连续访问两次，第一次需要输入用户名密码，第二次不用就可以直接登陆了？
	*浏览器A第一次访问网站1时，浏览器A会携带该网址对应的cookie(cookie包含seesionId)去访问服务器，服务器会查看自己已有的sessionId是否有和浏览器带来的cookie中sessionId相同的，
	 因为是第一次访问，没有相同的，服务器会创建一个新的sessionId，给cookie，这时候用户输入用户名密码进行登陆。当用户继续用浏览器A访问同一个网站，由于之前已经访问过，所以，
	 服务器会查到浏览器携带的Cookie中的sessionId,有和服务器中已有的SessionId一致的，所以服务器程序通过判断，该用户之前已经登陆过了，所以第二次访问的时候就不需要再登陆了。
	 如果此时再用浏览器B访问网站1，由于是新的浏览器，那么其中是没有上一个浏览器的cookie的，所以此时，服务器会重新分配一个新的sessionId给浏览器B，同样需要重新填写用户名密码进行登陆。

*Java设计模式
	0简单工厂模式
		*生产电脑，分为hp电脑和lenovo电脑
		01普通
			*创建两个电脑的共同接口
			public interface Computer{
				public void create();
			}
			*创建两个实现类
			public class HpComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is HpComputer");
				}
			}
			public class LenovoComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is LenovoComputer");
				}
			}
			*创建工厂类
			public class ComputerFactory{
				public Computer produce(String type){
					if("Hp".equals(type)){
						return new HpComputer();
					}else if("Lenovo".equals(type)){
						return new LenovoComputer();
					}else{
						System.out.println("请输入正确的类型！");
						return null;
					}
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					ComputerFactory factory = new ComputerFactory();
					Computer computer = factory.produce("Hp");
					computer.create();
				}
			}
			*输出：this is HpComputer
		02多个方法
			*对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象
			而多个工厂方法模式是提供多个工厂方法，分别创建对象。
			*修改ComputerFactory
			public class ComputerFactory{
				public Computer produceHp(){
					return new HpComputer();
				}
				public Computer produceLenovo(){
					return new LenovoComputer();
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					ComputerFactory factory = new ComputerFactory();
					Computer computer = factory.produceHp();
					computer.create();
				} 
			}
			*输出： this is HpComputer
		03多个静态方法
			*将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
			*修改ComputerFactory
			public class ComputerFactory{
				public static Computer produceHp(){
					return new HpComputer();
				}
				public static Computer produceLenovo(){
					return new LenovoComputer();
				}
			}
			*测试
			public class FactoryTest{
				public static void main(String[] args){
					Computer computer = ComputerFactory.produceHp();
					computer.create();
				} 
			}
			*输出： this is HpComputer
	*总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
	 在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，
	 所以，大多数情况下，我们会选用第三种——静态工厂方法模式。
 
	1工厂方法模式
		*简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，因此，就用到工厂方法模式。
		 一旦需要增加新的功能，直接增加新的接口实现类和新的工厂类就可以了，不需要修改之前的代码。
		*创建两个电脑的共同接口
			public interface Computer{
				public void create();
			}
			*创建两个实现类
			public class HpComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is HpComputer");
				}
			}
			public class LenovoComputer implements Computer{
				@Override
				public void create(){
					System.out.println("this is LenovoComputer");
				}
			}
			*创建两个工厂类
			public class HpComputerFactory implements Provider{
				@Override
				public Computer produce(){
					return new HpComputer();
				}
			}
			public class LenovoComputerFactory implements Provider{
				@Override
				public Computer produce(){
					return new LenovoComputer();
				}
			}
			*再提供一个工厂接口
			public interface Provider{
				public Computer produce();
			}
			*测试类
			public class Test{
				public static void main(String[] args){
					Provider provider = new HpComputerFactory();
					Computer computer = provider.produce();
					computer.create();
				}
			}
			*输出： this is HpComputer
			*其实这个模式的好处就是，如果你现在想增加一个功能：创建华硕电脑，则只需做一个实现类，实现Computer接口，
			 同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
	
	2抽象工厂模式
		*我们一直都是生产联想和惠普的电脑，但是电脑也有多个产品线：台式机、笔记本和平板等等，联想和惠普都在生产这些
		 不同产品线上的电脑，使用工厂方法模式已经满足不了需求，因此我们需要使用抽象工厂模式来解决这一问题。
		*抽象产品
			*定义抽象产品类
			public abstract class DesktopComputer {
			  public abstract void start();
			}
			public abstract class NotebookComputer {
			   public abstract void start();
			}
			*两个抽象产品类分别为DesktopComputer和NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，
			 用来启动电脑。
		*具体产品
			*具体产品为联想和惠普旗下的台式机和笔记本，如下所示。
			public class LenovoDesktopComputer extends DesktopComputer {
				@Override
				public void start() {
					System.out.println("联想台式电脑启动");
				}
			}

			public class HpDesktopComputer extends DesktopComputer {
				@Override
				public void start() {
					System.out.println("惠普台式电脑启动");
				}
			}

			public class LenovoNotebookComputer extends NotebookComputer {
				@Override
				public void start() {
					System.out.println("联想笔记本电脑启动");
				}
			}
			public class HpNotebookComputer extends NotebookComputer {
				@Override
				public void start() {
					System.out.println("惠普笔记本电脑启动");
				}
			}
		*抽象工厂
			*接着创建生产电脑的抽象工厂，如下所示，
			public abstract class ComputerFactory {
				public abstract DesktopComputer createDesktopComputer();
				public abstract NotebookComputer createNotebookComputer();
			}
			*定义了两个方法，分别用来生产台式电脑和笔记本电脑
		*具体工厂
			*定义联想和惠普工厂：
			public class LenovoFactory extends ComputerFactory {
				@Override
				public DesktopComputer createDesktopComputer() {
					return new LenovoDesktopComputer();
				}
				@Override
				public NotebookComputer createNotebookComputer() {
					return new LenovoNotebookComputer();
				}
			}

			public class HpFactory extends ComputerFactory {
				@Override
				public DesktopComputer createDesktopComputer() {
					return new HpDesktopComputer();
				}

				@Override
				public NotebookComputer createNotebookComputer() {
					return new HpNotebookComputer();
				}
			}
			*联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。
		*客户端调用
			public class Client {
				public static void main(String[]args) {
					ComputerFactory lenocoFactory=new LenovoFactory();
					lenocoFactory.createDesktopComputer().start();
					lenocoFactory.createNotebookComputer().start();
					ComputerFactory hpFactory=new HpFactory();
					hpFactory.createDesktopComputer().start();
					hpFactory.createNotebookComputer().start();
				}
			}
		*工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"。
		 抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上。
	 
	3.代理模式
		*其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？
		 因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，
		 因为律师在法律方面有专长，可以替我们进行操作。
		
		*接口类：
		package proxy.staticproxy;
		public interface Person {
			void giveMoney();
		}
		
		*一个实现了接口类的实体类：
		package proxy.staticproxy;
		public class Student implements Person {
			@Override
			public void giveMoney() {
				System.out.println(name +" 上交班费50元！");
			}
			private String name;

			public Student(String name){
				this.name = name;
			}
		}
		
		*一个代理类，代理类实现了接口类，并且还“爱管闲事”，调用了上面实体类的方法。
		package proxy.staticproxy;
		/**
		 * 如果使用动态代理这个类会被自动创建， 代理类的工作就是把实体类接过来，然后调用它的方法，也就是说本来实体类可以自己执行的方法现在由代理类来触发执行，这样做的好处是，在调用实体类方法的前后我们可以插入监控方法。比如这里只插入了一句话“这位同学最近学习有进步”
		 */
		public class StudentProxy implements Person {
			@Override
			public void giveMoney() {
				System.out.println("这位同学最近学习有进步！");
				stu.giveMoney();
			}

			Student stu;

			public StudentProxy (Person stu){
				if(stu.getClass() == Student.class){ //person 可以是学生，老师等， 但是这里只为学生交钱
					this.stu = (Student)stu;
				}
			}
		}
		
		*最后有一个统管类, 生成一个实体类，并指挥代理类去调用实体类：
		public class StaticProxyTest {
			public static void main(String[] args) {
				Person zhangsan = new Student("张三");

				Person monitor = new StudentProxy(zhangsan); // 为了帮张三交班费而生产一个班长角色
				monitor.giveMoney();
			}
		}
		
		*代理模式的应用场景：
		如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
		1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
		2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
		   使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
		   
	4.单例模式
		*单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例。
		 主要解决：一个全局使用的类频繁地创建与销毁。
		
		*懒汉式，线程不安全
			是否 Lazy 初始化：是
			是否多线程安全：否
			实现难度：易
			描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
				  这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。
				  
			public class Singleton {  
				private static Singleton instance;  
				private Singleton (){}  
			  
				public static Singleton getInstance() {  
				if (instance == null) {  
					instance = new Singleton();  
				}  
				return instance;  
				}  
			}
			
		*懒汉式，线程安全
			是否 Lazy 初始化：是
			是否多线程安全：是
			实现难度：易
			描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
			优点：第一次调用才初始化，避免内存浪费。
			缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
			getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁,其实只有在创建对象的时候才需要加锁）。
			
			public class Singleton {  
				private static Singleton instance;  
				private Singleton (){}  
				public static synchronized Singleton getInstance() {  
				if (instance == null) {  
					instance = new Singleton();  
				}  
				return instance;  
				}  
			}
			
		*饿汉式
			是否 Lazy 初始化：否
			是否多线程安全：是
			实现难度：易
			描述：这种方式比较常用，但容易产生垃圾对象。
			优点：没有加锁，执行效率会提高。
			缺点：类加载时就初始化，浪费内存。
			它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，
			在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。
			
			public class Singleton {  
				private static Singleton instance = new Singleton();  
				private Singleton (){}  
				public static Singleton getInstance() {  
				return instance;  
				}  
			}
			
		*双检锁/双重校验锁
			JDK 版本：JDK1.5 起
			是否 Lazy 初始化：是
			是否多线程安全：是
			实现难度：较复杂
			描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
			getInstance() 的性能对应用程序很关键。

			public class Singleton {  
				private volatile static Singleton singleton;  
				private Singleton (){}  
				public static Singleton getSingleton() {  
				if (singleton == null) {  
					synchronized (Singleton.class) {  
					if (singleton == null) {  
						singleton = new Singleton();  
					}  
					}  
				}  
				return singleton;  
				}  
			}

		*登记式/静态内部类
			是否 Lazy 初始化：是
			是否多线程安全：是
			实现难度：一般
			描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用（？）。
			这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），
			而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。
			想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 
			instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。
			
			public class Singleton {  
				private static class SingletonHolder {  
				private static final Singleton INSTANCE = new Singleton();  
				}  
				private Singleton (){}  
				public static final Singleton getInstance() {  
				return SingletonHolder.INSTANCE;  
				}  
			}

		*枚举
			JDK 版本：JDK1.5 起
			是否 Lazy 初始化：否
			是否多线程安全：是
			实现难度：易
			描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
			这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
			不能通过 reflection attack 来调用私有构造方法。
		
			public enum Singleton {  
				INSTANCE;  
				public void whateverMethod() {  
				}  
			}
		
		*经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。
		           只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，
				   可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。
		*优点：     1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
					2、避免对资源的多重占用（比如写文件操作）。 
					
		*缺点：		1、违反了单一责任链原则，测试困难
						单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，
						同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
					2、扩展困难
						由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。修改功能必须修改源码。
					3、共享资源有可能不一致。
						现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。
		
		*应用场景： 1、要求生产唯一序列号。
					2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
					3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
		
*Java 中操作字符串都有哪些类？它们之间有什么区别？
	*操作字符串的类有：String、StringBuffer、StringBuilder。
	*String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，
	*StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。
	*StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，
	 所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
	 
*如何将字符串反转？
	使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。
	
*String str="i"与 String str=new String("i")一样吗？
	不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

*JVM内存模型
	*java虚拟机在执行程序过程中会把它所管理的内存划分为几个不同的区域：
	方法区、java堆、java栈、本地方法栈、程序计数器
	其中，java栈、本地方法栈、程序计数器是线程隔离的区域，每个线程都有各自的一份，而方法区，
	java栈是线程共享的。
	*程序计数器
		*程序计数器又叫指令计数器，用来确定cpu下一条要执行的指令的地址。如果当前线程正在执行一个java方法，则程序计数器记录正在执行的java字节码地址，
		 如果当前线程正在执行一个本地方法，那么程序计数器为空。
	*java栈
		*每一个线程都有一个私有的java栈，java栈在线程创建的时候被创建，其中保存着帧信息。每个java方法在执行的同时都会创建一个栈帧，用于保存局部变量、方法参数、
		 方法出口等信息，每一个方法从调用到执行完成的过程，都对应着一个栈帧在java栈中入栈到出栈的过程）
		 栈的优势去访问速度比堆要快，仅次于程序计数器。
	*本地方法栈
		*本地方法栈和java栈非常类似，不同之处在于java栈用于java方法的调用，而本地方法栈用于本地方法的调用。
         注意：本地方法栈不是用java实现的，而是使用C实现的。
	*java堆
		*堆在JVM启动的时候会被创建，我们可以把它理解成一个内存池，用来存放所有的java对象，所有的线程共享java堆。
	*方法区（包含常量池）
		*方法区和堆一样是所有线程共享的区域，主要保存的信息是类的元数据，包括类的类型信息、常量、静态变量、域信息、方法信息等数据。
 
*接口和类
	*java之所以引入接口，就是为了弥补不能多继承的缺点，在java中每个类只能有一个超类，但却可以实现多个接口。
	*接口的思想不允许出现变量，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放。所以接口中的属性必然是常量，
	 只能读不能改，这样才能为实现接口的对象提供一个统一的属性。
	*接口可以有静态常量，并且这个常量一定是静态的，为什么？
　　 因为static是所有对象可以访问，而且可以直接通过类名访问。接口没有对象，必须通过类名来访问所以是要静态的。
	
	*区别：
		*实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
		*构造函数：抽象类可以有构造函数；接口不能有。
		*实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
		*访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

*抽象类能使用 final 修饰吗？
	不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，

*null != a 要比a != null 好
	在于避免由于编码失误造成把a赋值为null,只是编码风格上的区别，效率是一样的； 
	这个与equals是类似的。比如 
	String str = ..; 
	if(str.equals("admin")) 
	这样使用的话，一旦str是null将导致空指针异常，所以我们推荐使用 
	if("admin".equals(str)) 
	这样就没有问题了
	
*阻塞和非阻塞 同步和异步
	*同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，
	 两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。
	 至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。
	*阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，
	 等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 
	 使用时间能不能补偿系统的切换成本需要好好评估。
	 
*BIO、NIO、AIO的区别
    BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，
	    它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。
    NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。
    AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，
	    也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

*Java 容器都有哪些？
	Java容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：
    Collection
    List
        ArrayList
        LinkedList
        Vector
        Stack
    Set
        HashSet
        LinkedHashSet
        TreeSet
		
    Map
    HashMap
        LinkedHashMap
    TreeMap
    ConcurrentHashMap
    Hashtable

*Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。
 Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。

*HashMap 和 Hashtable 有什么区别？
    存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。
    线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。
    推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。

* HashMap 的实现原理？
	HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 
	保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。

*Vector
	Vector 可实现自动增长的对象数组。 
	java.util.vector提供了向量类(Vector)以实现类似动态数组的功能。 
	创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。	
	对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况，可以考虑使用向量类。
	
*ArrayList 和 Vector 的区别是什么？
    线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
    性能：ArrayList 在性能方面要优于 Vector。
    扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。
	
*Array 和 ArrayList 有何区别？
    Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。
    Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。
    Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。
	
*在Queue 中 poll()和 remove()有什么区别？
    相同点：都是返回第一个元素，并在队列中删除返回的对象。
    不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常
	
*Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。也可以通过Iterator去删除元素。 
 Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
 
*Iterator 和 ListIterator 有什么区别？
    Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。
    Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。
    ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。

*怎么确保一个集合不能被修改？
	可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。

*反射
	正射：直接对这个类进行实例化，之后使用这个类对象进行操作。
		Phone phone = new Phone(); //直接初始化，「正射」
		phone.setPrice(4);
	反射：一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。
		Class clz = Class.forName("com.xxp.reflect.Phone");
		Method method = clz.getMethod("setPrice", int.class);
		Constructor constructor = clz.getConstructor();
		Object object = constructor.newInstance();
		method.invoke(object, 4);
	所以：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
	
*获取反射中的Class对象
	在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。
	在 Java API 中，获取 Class 类对象有三种方法：
    *使用 Class.forName 静态方法。当知道某类的全路径名时，可以使用此方法获取 Class 类对象。用的最多，但可能抛出 ClassNotFoundException 异常。
     Class c1 = Class.forName(“java.lang.String”);
    *直接通过 类名.class 的方式得到，该方法最为安全可靠，程序性能更高。这说明任何一个类都有一个隐含的静态成员变量 class。这种方法只适合在编译前就知道操作的 Class。
     Class c2 = String.class;
    *通过对象调用 getClass() 方法来获取，通常应用在：比如你传过来一个 Object类型的对象，而我不知道你具体是什么类，用这种方法。

*通过反射创建类对象
	通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。
    通过 Class 对象的 newInstance() 方法。
		Class clz = Phone.class;
		Phone phone = (Phone)clz.newInstance();
    通过 Constructor 对象的 newInstance() 方法
		Class clz = Phone.class;
		Constructor constructor = clz.getConstructor();
		Phone phone= (Phone)constructor.newInstance();
	通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。
	
*通过反射获取类属性、方法、构造器
	我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。
		Class clz = Phone.class;
		Field[] fields = clz.getFields();
		for (Field field : fields) {
			System.out.println(field.getName());
		}
	如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：
		Class clz = Phone.class;
		Field[] fields = clz.getDeclaredFields();
		for (Field field : fields) {
			System.out.println(field.getName());
		}
	与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。

*反射应用场景
	反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，
	并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，
	降低代码的耦合度；还有动态代理的实现；JDBC原生代码注册驱动；hibernate的实体类；hibernate数据查询：Spring的AOP等等。

*new和反射创建对象的区别
	*首先new出来的对象我们无法访问其中的私有属性，但是通过反射出来的对象我们可以通过setAccessible()方法
	 来访问其中的私有属性。
	*在使用new创建一个对象实例的时候必须知道类名，但是通过反射创建对象有时候不需要知道类名也可以	
     （ 首先要使用反射创建对象必须要得到类的Class对象，至于怎么得到这个Class对象，有很多方法例如对于类A及其
		实例str_a来说可以使用A.class()，str_a.getClass()或者Class.forName("A")。这几种方法无一例外都需要使用到类名来
		获取类Class对象，但是有一种方式是不需要类名的，那就是jdk的动态代理。动态代理是一种在运行期动态生成字节
		码并转换成代理类Class对象的一种方法
	  ）
	  
* 什么是 Java 序列化？什么情况下需要序列化？
	*Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。
	*以下情况需要使用 Java 序列化：
		想把的内存中的对象状态保存到一个文件中或者数据库中时候；
		想用套接字在网络上传送对象的时候；
		想通过RMI（远程方法调用）传输对象的时候。

*java程序编译和运行
	编译：XXX.java --> XXX.class。编译时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类。
		  编译后的字节码文件主要分成两部分：常量池和方法字节码。
		  
	运行：分两个过程：类的加载和类的执行
		  JVM在程序第一次主动使用类的时候，才加载该类。所以，jvm并不是在一开始就把一个程序所有的类都加载到内存（
		  例如：命令行敲java AppMain 系统先加载MainApp类，然后执行main函数，这时发现main函数第一条命令是Animal animal = new Animal()，这时jvm才去加载Animal类）。
参考链接：https://blog.csdn.net/cynhafa/article/details/82425456

*动态代理
	*与静态代理区别：代理类在程序运行时根据我们在java代码中的“指示”创建代理的方式被称为动态代理。而静态代理在程序编译的时候就已经将接口，被代理类，代理类确定下来了。
		             相比与静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用说修改每个代理类中的方法。比如说：在静态代理中，班长帮学生交学费，
					 静态代理中有giveMoney()方法，里面调用的是stu.giveMoney(),我们可以在交学费之前做一些处理，比如打印该学生所需交的费用，如果这时又有另外一个交伙食费的方法，
					 我们同样需要在交伙食费之前打印费用信息，这时，需要再次在stu.giveFoodMoney()方法之前添加打印方法，这样一来，打印费用方法就要写很多次，而动态代理，只需写一次即可。
	*动态代理实现：jdk的动态代理主要是通过Proxy类和InvocationHandler接口生成JDK动态代理类和动态代理对象。其中：InvocationHandler用于表示在执行某个方法之前，之后你想加入什么（监控）代码。
				   Proxy用于自动生成代理类，InvocationHandler将会作为Proxy的一个参数来生成代理类。
				   两者通过Proxy.newInstance()方法进行关联，invocationHandler会作为参数传入Proxy， 由Proxy在编译的时候加工自动生成代理类，这个生成的代理类里就会有invocationHandler里指定的要执行的代码

					public class ProxyTest {
					public static void main(String[] args) {
						
							//创建一个实例对象，这个对象是被代理的对象
							Person zhangsan = new Student("张三");
							
							//创建一个与代理对象相关联的InvocationHandler
							//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
							Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class<?>[]{Person.class}, new StuInvocationHandler<Person>(zhangsan))；

						   //代理执行上交班费的方法
							stuProxy.giveMoney();
						}
					}
					

					import java.lang.reflect.InvocationHandler;
					import java.lang.reflect.Method;

					public class StuInvocationHandler<T> implements InvocationHandler {
						T target;

						public StuInvocationHandler(T target){
							this.target = target;
						}
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							System.out.println("代理执行"+method.getName()+"方法");

							MonitorUtil.start(); //这是一个本地静态工具类，用于记下方法开始时间
							Object result = method.invoke(target, args);
							MonitorUtil.finish(method.getName());//这是一个本地静态工具类，用于记下方法执行完成的时间
							return result;
						}
					}
参考链接：https://www.jianshu.com/p/4e14dd223897      
          https://www.cnblogs.com/gonjan-blog/p/6685611.html
			 
*Sring的两种动态代理：Jdk和Cglib
	*JDK:java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
	*Cglib:而cglib动态代理是利用asm开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
	区别：（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类
		  （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
               因为是继承，所以该类或方法最好不要声明成final 
	注意： 1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
		   2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
           3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
具体区别及实现见链接：https://www.cnblogs.com/leifei/p/8263448.html

*JSP 和 servlet 有什么区别？
	JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，
	servlet的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，
	而JSP的情况是Java和html可以组合成一个扩展名为 JSP 的文件。
	JSP 侧重于视图，servlet主要用于控制逻辑。
	
*JSP 有 9 大内置对象：
    request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；
    response：封装服务器对客户端的响应；
    pageContext：通过该对象可以获取其他对象；
    session：封装用户会话的对象；
    application：封装服务器运行环境的对象；
    out：输出服务器响应的输出流对象；
    config：Web 应用的配置对象；
    page：JSP 页面本身（相当于 Java 程序中的 this）；
    exception：封装页面抛出异常的对象。
	
*JSP 的 4 种作用域？
    page：代表与一个页面相关的对象和属性。
    request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。
    session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。
    application：生命周期：从Web服务器启动，直到Web服务器关闭。
				 作用范围：application对象是一个应用程序级的对象，它作用于当前Web应用程序，也即作用于当前网站，所有访问当前网站的客户都共享一个application对象。
						   可实现多客户之间的数据共享。
						   
*session 和 cookie 有什么区别？
    存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。
    安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。
    容量和个数限制：cookie 有容量限制（4KB 一个cookie），每个站点下的 cookie 也有个数限制（50）。
    存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。
	
* session 的工作原理？
	session的工作原理是客户端登录完成之后，服务器会创建对应的session，session创建完之后，会把session 
	的id发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 
	sessionid之后，在内存找到与之对应的session这样就可以正常工作了。

*如果客户端禁止cookie，session 还能用吗？
	可以用，session只是依赖cookie存储sessionid，如果cookie被禁用了，可以使用url中添加sessionid的方式保证sessions能正常使用。
	
*拦截器与过滤器
	*拦截器：拦截器是对调用的Action起作用，它提供了一种机制可以使开发者定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。
		     很多业务逻辑都是靠拦截实现的，比如校验，验证登录权限(比如下载时跳转到登陆页面)等等。
	*过滤器：过滤器是对整个的请求过程起作用！换句话说就是拦截器没有过滤器的范围广。过滤器是在java web中，你传入的request,response提前过滤掉一些信息，
	         或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,
			 或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话，比如判断用户提交的数据是否存在非法字符等等。

*Struts中拦截器执行的几种情况
	1) 中止整个执行，直接返回一个字符串作为resultCode 
　	2) 通过递归调用负责调用堆栈中下一个Interceptor的执行 
　　3) 如果在堆栈内已经不存在任何的Interceptor，调用Action

*spring mvc 和 struts 的区别是什么？
    *拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。
    *数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。
    *拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。
    *对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。

*SQL注入
	含义：SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。
	避免sql注入：1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和
					双"-"进行转换等。
				 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
				 3.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。
				 
*XSS攻击
	XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。
			  预防 XSS 的核心是必须对输入的数据做过滤处理。

*什么是 CSRF 攻击，如何避免？
	CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。
	防御手段：
		验证请求来源地址；
		关键操作添加验证码；
		在请求地址添加 token 并验证。
	
*throw 和 throws 的区别？
    throw：是真实抛出一个异常。
    throws：是声明可能会抛出一个异常。
	
*final、finally、finalize 有什么区别？
    final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。
    finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。
    finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。

*try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
	finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。
	
*常见的异常类有哪些？
    NullPointerException 空指针异常
    ClassNotFoundException 指定类不存在
    NumberFormatException 字符串转换为数字异常
    IndexOutOfBoundsException 数组下标越界异常
    ClassCastException 数据类型转换异常
    FileNotFoundException 文件未找到异常
    NoSuchMethodException 方法不存在异常
    IOException IO 异常
    SocketException Socket 异常
	
*forward 和 redirect 的区别？
	forward 是转发 和 redirect 是重定向：
    地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；
    数据共享：forward 可以共享 request 里的数据，redirect 不能共享；
    效率：forward 比 redirect 效率高。

* tcp 为什么要三次握手，两次不行吗？为什么？
	如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，
	那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有
	收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。
链接：https://blog.csdn.net/lengxiao1993/article/details/82771768

*get和post的区别
	*GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
		get 请求会被浏览器主动缓存，而 post 不会。
		get 传递参数有大小限制（2KB），而 post 没有。
		post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。
		注意：*GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。
              而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
			  *在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
			   并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 
链接：https://www.cnblogs.com/logsharing/p/8448446.html

*ajax和jsonp的区别
	1、ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。
	2、实质不同
　　	ajax的核心是通过xmlHttpRequest获取非本页内容；
　　	jsonp的核心是动态添加script标签调用服务器提供的js脚本（后缀.json)。
	3、区别联系
　　	ajax与jsonp的区别也不在于是否跨域。ajax禁止跨域，但通过服务端代理一样跨域；jsonp是为了解决ajax禁止跨域的问题，但jsonp并不排斥同域的数据的获取。
	4、jsonp是一种方式或者说非强制性的协议，ajax也不一定非要用json格式来传递数据。
	5、jsonp只支持get请求，ajax支持get和post请求。
jsonp的介绍链接：https://blog.csdn.net/hansexploration/article/details/80314948

*Spring的IOC有五种注入方式：构造器注入、setter方法注入、静态工厂注入、实例工厂注入、根据注解注入
	*对上述分类可分为两种：
		*xml配置声明注册。然后setter、构造器注入、静态工厂注入、实例工厂注入；
		*注解方式声明注册，然后是注解方式注入
		
	*构造器注入：
		*在applicationContext.xml配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的某个有参数的构造方法
			<!-- 注册userService -->
			<bean id="userService" class="com.lyu.spring.service.impl.UserService">
				<constructor-arg ref="userDaoJdbc"></constructor-arg>
			</bean>
			<!-- 注册jdbc实现的dao -->
			<bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"></bean>
		*如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中
			public class UserService implements IUserService {

				private IUserDao userDao;
				
				public UserService(IUserDao userDao) {
					this.userDao = userDao;
				}
				
				public void loginUser() {
					userDao.loginUser();
				}

			}
			
		*测试
			@Test
			public void testDI() {
				ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
				// 获取bean对象
				UserService userService = ac.getBean(UserService.class, "userService");
				// 模拟用户登录
				userService.loginUser();
			}
		*注意：
			*如果有多个有参数的构造方法并且每个构造方法的参数列表里面都有要注入的属性，那userDaoJdbc会注入到哪里呢？
			 结果：会注入到只有一个参数的构造方法中，并且经过测试注入哪一个构造方法与构造方法的顺序无关
			
			*如果只有一个构造方法，但是有两个参数，一个是待注入的参数，另一个是其他类型的参数，那么这次注入可以成功吗？
			 结果：失败了，即使在costract-arg标签里面通过name属性指定要注入的参数名userDao也会失败.

			*如果我们想向有多个参数的构造方法中注入值该在配置文件中怎么写呢？
				public class UserService implements IUserService {

					private IUserDao userDao;
					private User user;
					
					public UserService(IUserDao userDao, User user) {
						this.userDao = userDao;
						this.user = user;
					}
					
					public void loginUser() {
						userDao.loginUser();
					}

				}
			 参考写法：通过name属性指定要注入的值，与构造方法参数列表参数的顺序无关。
				<!-- 注册userService -->
				<bean id="userService" class="com.lyu.spring.service.impl.UserService">
					<constructor-arg name="userDao" ref="userDaoJdbc"></constructor-arg>
					<constructor-arg name="user" ref="user"></constructor-arg>
				</bean>

				<!-- 注册实体User类，用于测试 -->
				<bean id="user" class="com.lyu.spring.entity.User"></bean>

				<!-- 注册jdbc实现的dao -->
				<bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"></bean>
			
			*如果有多个构造方法，每个构造方法只有参数的顺序不同，那通过构造方法注入多个参数会注入到哪一个呢？
			 结果：哪个构造方法在前就注入哪一个，这种情况下就与构造方法顺序有关。
			
	*setter注入
		*配置文件如下
			<!-- 注册userService -->
			<bean id="userService" class="com.lyu.spring.service.impl.UserService">
				<!-- 写法一 -->
				<!-- <property name="UserDao" ref="userDaoMyBatis"></property> -->
				<!-- 写法二 -->
				<property name="userDao" ref="userDaoMyBatis"></property>
			</bean>

			<!-- 注册mybatis实现的dao -->
			<bean id="userDaoMyBatis" class="com.lyu.spring.dao.impl.UserDaoMyBatis"></bean>
		注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上"set"构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。
		
		*setter注入
			public class UserService implements IUserService {

				private IUserDao userDao1;
				
				public void setUserDao(IUserDao userDao1) {
					this.userDao1 = userDao1;
				}
				
				public IUserDao getUserDao(){
					return userDao1;
				}
				
				public void loginUser() {
					userDao1.loginUser();
				}

			}
			
	*静态工厂注入
		利用静态工厂方法可以把bean注入到IOC容器中。在XML文件中配置bean时，要指定class的属性为工厂的类；factory-method属性指定工厂类中工厂方法，用于创建bean；constrctor-arg用于给工厂方法传递参数。
			*实体类
			    package org.spring.chapter2.helloworld;  
      
				public class HelloImpl3 implements HelloApi {  
				  
					private String message;  
					private int index;  
					  
					public HelloImpl3() {  
						this.message="Hello World in Empty Constructor";  
					}  
				  
					public HelloImpl3(String message,int index) {  
						this.message = message;  
						this.index = index;  
					}  
				  
					@Override  
					public void sayHello() {  
						System.out.println(index+":"+message);  
					}  
				  
				}  
			*静态工厂
			    package org.spring.chapter2.helloworld;  
      
				public class InJectByStaticFactory {  
				  
					public static HelloApi newInstance(String message,int index){  
						return new HelloImpl3(message,index);  
					}  
				}  
				
			*beans.xml
			    <?xml version="1.0" encoding="UTF-8"?>  
				<beans xmlns="http://www.springframework.org/schema/beans"  
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"  
					xsi:schemaLocation="http://www.springframework.org/schema/beans     
										http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
										http://www.springframework.org/schema/context             
										http://www.springframework.org/schema/context/spring-context-3.0.xsd">  
					<!-- 通过构造器参数索引方式依赖注入 -->    
					<bean id="byIndex" class="org.spring.chapter2.helloworld.InJectByStaticFactory" factory-method="newInstance">  
					   <constructor-arg index="0" value="Hello Spring By Index" />  
					   <constructor-arg index="1" value="1"></constructor-arg>  
					</bean>  
				</beans>  
			
			*测试
			    @Test  
				public void testStaticConstructInject(){  
					ApplicationContext context = new ClassPathXmlApplicationContext("org/spring/chapter2/helloworld/helloworld5.xml");  
					  
					//1:按照参数索引依赖注入的Bean  
					HelloApi byIndex = context.getBean("byIndex",HelloApi.class);  
					byIndex.sayHello();  
				}  
	*实例工厂注入
		实例化静态工厂注入bean，需要先实例化一个工厂类，然后通过由实例化工厂对象中的一个方法来创建bean，并注入到容器中。
		在 bean 的 factory-bean 属性里指定拥有该工厂方法的 Bean；在 factory-method 属性里指定该工厂方法的名称；使用 construtor-arg 元素为工厂方法传递方法参数。
			*beans.xml
				<!--首先创建一个工厂的bean-->
				<bean id="carFactory" class="com.lzj.spring.beans.factory.InstanceFactory"></bean>
				<!--factory-bean指定前面已经创建的bean; factory-method指定工厂实例中用于创建car的方法； constructor-arg指定创建car方法中传入的参数-->
				<bean id="car2" factory-bean="carFactory" factory-method="getCar">
					<constructor-arg value="baoma"></constructor-arg>
				</bean>
				
			*测试
				ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml");
				Car car = (Car) ctx.getBean("car2");
				System.out.println(car);
	链接：使用静态工厂方法注入https://www.iteye.com/blog/liuyiyou-1614833
		  静态工厂方法和实例工厂方法注入bean https://blog.csdn.net/u010502101/article/details/78638449


	*基于注解的注入
		*在使用注解注入之前，需要先进行注册，可使用以下四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：
			@Component：可以用于注册所有bean
			@Repository：主要用于注册dao层的bean
			@Controller：主要用于注册控制层的bean
			@Service：主要用于注册服务层的bean
			
		*基于注解的注入分两类
			*@Autowired Spring的注解
				@Autowired可对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过@Autowired的使用来消除
				上述setter注入的set，get方法。
				
				在使用@Autowired之前，需要 在applicationContext.xml中加入： 
				<!-- 该 BeanPostProcessor 将自动对标注 @Autowired 的 Bean 进行注入 -->   
				<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/> 
				Spring 通过一个 BeanPostProcessor 对 @Autowired 进行解析，所以要让 @Autowired 起作用必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor Bean。
					
				*对类成员变量标注
					public class Boss {   
						@Autowired  
						private Car car;   
						@Autowired  
						private Office office;   
					}  
					当 Spring 容器启动时，AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有 @Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。   
					按照上面的配置，Spring 将直接采用 Java 反射机制对 Boss 中的 car 和 office 这两个私有成员变量进行自动注入。	
				
				*对方法进行标注
					public class Boss {   
						private Car car;   
						private Office office;   
						@Autowired  
						public void setCar(Car car) {   
							this.car = car;  
						}   
						@Autowired  
						public void setOffice(Office office) {   
							this.office = office;   
						}   
					}  
					@Autowired 将查找被标注的方法的入参类型的 Bean，并调用方法自动注入这些 Bean。
				
				*对构造函数进行标注
					package com.baobaotao;   
					public class Boss {   
						private Car car;   
						private Office office;   
						@Autowired  
						public Boss(Car car ,Office office){   
							this.car = car;   
							this.office = office ;   
						}   
					}  
					由于 Boss() 构造函数有两个入参，分别是 car 和 office，@Autowired 将分别寻找和它们类型匹配的 Bean，将它们作为 Boss(Car car ,Office office) 的入参来创建 Boss Bean。 
			注意：*@Autowired默认根据类型，匹配不到则根据bean名字。
				  *一个接口只有一个实现的情况下，属性名字怎么写都无所谓，因为按照类型匹配就只有一个bean
				  *一个接口多个实现的情况下：
　　				*属性名字跟组件名字一致，组件名字可以在声明的时候指定，比如 @Service("abc")
 　　				*属性名字跟组件名字不一致，配合@Qualifier 注解指定组件名字
						例如：
						@Service
						public class HelloServiceImpl implements HelloService {
							@Override
							public void sayHello() {
								System.out.println("say hello impl");
							}
						}
						
						@Controller
						public class HelloController {
							@Autowired
							@Qualifier("helloServiceImpl")
							private HelloService abc;
							
							public void hello() {
								abc.sayHello();
							}
						}
			*@Resource java的注解
				*默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。
				@Resource
				@Qualifier("userDaoMyBatis")
				private IUserDao userDao;

				public UserService(){
					
				}
			注意：在匹配到多个 bean 的情况下，JDK自带的ByName需要遍历所有的bean，而@Qualifier 直接一次定位。
				  因此，@Qualifer 注解出现的意义或许就是 Spring 为了解决 JDK 自带的 ByName 遍历匹配效率低下的问题。
链接：Spring常用的三种注入方法:https://blog.csdn.net/a909301740/article/details/78379720
	  Spring中@Autowired 注解的注入规则:https://www.cnblogs.com/convict/p/10688335.html
	  Spring@Autowired注解与自动装配:https://www.cnblogs.com/feng9exe/p/11215220.html
	  
*java中classpath路径详解
	1、在编译生成的文件.classpath 中kind="src" 的类型为classpath 路径，在项目里可以用classpath：xxx方式引用。也可以手动过来自己添加、扩大classpath的范围，  <classpathentry kind="src" path="XXX"/>.
	   也就是说你想知道classpath指的是哪里点开.classpath 看看kind="src" 的就知道了
	2、在编译生成的项目下的bulid/classes/ 下具有的文件都是classpath 路径下的文件，都可以通过classpath：方法获取。
	3、”src不是classpath, WEB-INF/classes,lib才是classpath”这句话不对，这是编写项目时看到的，真正的classpath是在编译后的bulid/classes/ （如2的解释）
链接：https://www.cnblogs.com/andy-alone/p/9210558.html

*BeanFactory和ApplicationContext有什么区别？
	*描述
		BeanFactory：
			是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；
		ApplicationContext：
			应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；
				1) 国际化（MessageSource）
				2) 访问资源，如URL和文件（ResourceLoader）
				3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  
				4) 消息发送、响应机制（ApplicationEventPublisher）
				5) AOP（拦截器）

	*两者装载bean的区别
		BeanFactory：
			BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化；
		ApplicationContext：
			ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化； 
			
	*我们该用BeanFactory还是ApplicationContent
		延迟实例化的优点：（BeanFactory）
			应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势； 
			
		不延迟实例化的优点： （ApplicationContext）
			1. 所有的Bean在启动的时候都加载，系统运行的速度快； 
			2. 在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题 
			3. 建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成） 
详情链接：https://www.iteye.com/blog/youyu4-2346183

*Spring框架中的单例Beans是线程安全的么？
    Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，
	所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”
	变更为“prototype”。
注意：此处的bean有状态与无状态是指：bean中是否有私有变量，如果有的话，bean中的多个方法就有可能改变该变量的值，从而这个bean的状态是变化的，此刻需要使用多例。
	  一般而言，还是应该尽量使用无状态Bean.如果在程序中出现私有变量，尽量替换为参数。对于每个访问私有变量的方法增加变量传入或者通过ThreadLocal来获取也是不错的方法。
	  
*Spring之自动装配的五种方式
	基于xml配置文件中的autowire来实现的spring自动装配，主要有以下五种具体的实现方式：

    1.no —— 默认情况，自动装配方式为手动装配，即通过ref手动设定

    2.byName —— 根据属性名称自动装配，如果一个bean的名称和其他bean属性一致，则进行自动装配

    3.byType——按照数据类型进行自动装配，如果一个bean的名称和其他bean的属性的数据类型一致，则进行兼容并自动装配

    4.constructor ——通过构造函数参数的byType方式。

    5.autodetect —— 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”。（已经遗弃了）
详情链接：https://blog.csdn.net/qq_24313635/article/details/82054239
